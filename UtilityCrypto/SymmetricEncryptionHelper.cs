
using System;
using System.Security.Cryptography;
using System.IO;

namespace Utility.Crypto
{
    /// <summary>
    /// Symmetric encryption utility to help with crypto agility and Key/IV generation
    /// </summary>
    public class SymmetricEncryptionHelper : IDisposable
    {
        private SymmetricAlgorithm _symmetricAlgorithm;

        #region Key and IV Retrieval

        public byte[] Key
        {
            get
            {
                if (_symmetricAlgorithm != null)
                {
                    return _symmetricAlgorithm.Key;
                }
                else
                {
                    return null;
                }
            }
        }

        public byte[] IV
        {
            get
            {
                if (_symmetricAlgorithm != null)
                {
                    return _symmetricAlgorithm.IV;
                }
                else
                {
                    return null;
                }
            }
        }

        #endregion Key and IV Retrieval

        #region Constructors

        /// <summary>
        /// Creates a SymmetricAlgorithm instance based on the algorithm name. 
        /// The Key and IV are derived from the password AND salt with 
        /// PasswordDerivedBytes utilizing the specified hash algorithm and 
        /// the specified number of iteration. 
        /// 
        /// You must supply the exact same parameters (includes the same 
        /// salt value) to decrypt the cypher.
        /// 
        /// On 6/28/2017, it is recommended to  use "Aes" as the algorithm 
        /// name and "SHA512" as the hash algorithm. You should make these 
        /// values configurable and have a code supported way to change them
        /// at any time. 
        /// </summary>
        /// <param name="algorithmName"></param>
        /// <param name="hashAlgorithmName"></param>
        /// <param name="iterations"></param>
        /// <param name="password"></param>
        /// <param name="salt"></param>
        public SymmetricEncryptionHelper(string algorithmName, string hashAlgorithmName, int iterations, string password, byte[] salt)
        {
            _symmetricAlgorithm = SymmetricAlgorithm.Create(algorithmName);
            var derivedBytes = new PasswordDeriveBytes(password, salt, hashAlgorithmName, iterations);
            _symmetricAlgorithm.Key = derivedBytes.GetBytes(_symmetricAlgorithm.KeySize / 8);
            _symmetricAlgorithm.IV = derivedBytes.GetBytes(_symmetricAlgorithm.BlockSize / 8);
        }

        /// <summary>
        /// Creates a SymmetricAlgorithm instance based on the algorithm name. 
        /// The Key and IV are generated by SymmetricAlgorithm. 
        /// 
        /// You must retrieve Key and IV and store them to decrypt the cipher
        /// text. This constructor can only be used for encryption, for 
        /// decryption you must use the constructor accepting a Key and IV 
        /// below.
        /// 
        /// On 6/28/2017, it is recommended to use "Aes" as the algorithm name You 
        /// should make these values configurable and have a code supported 
        /// way to change them at any time. 
        /// </summary>
        /// <param name="algorithmName"></param>
        public SymmetricEncryptionHelper(string algorithmName)
        {
            _symmetricAlgorithm = SymmetricAlgorithm.Create(algorithmName);
            _symmetricAlgorithm.GenerateKey();
            _symmetricAlgorithm.GenerateIV();
        }

        /// <summary>
        /// Creates a SymmetricAlgorithm instance based on the algorithm name. 
        /// The Key and IV are supplied by the caller. 
        /// 
        /// This constructor can only be used for encryption and decryption.
        /// The Key and IV must match the ones used for encryption to decrypt
        /// the cypher text.
        /// 
        /// On 6/28/2017, it is recommended to use "Aes" as the algorithm name You 
        /// should make these values configurable and have a code supported 
        /// way to change them at any time. 
        /// </summary>
        /// <param name="algorithmName"></param>
        /// <param name="key"></param>
        /// <param name="iv"></param>
        public SymmetricEncryptionHelper(string algorithmName, byte[] key, byte[] iv)
        {
            _symmetricAlgorithm = SymmetricAlgorithm.Create(algorithmName);
            _symmetricAlgorithm.Key = key;
            _symmetricAlgorithm.IV = iv;
        }

        #endregion Constructors

        #region Encrypt

        /// <summary>
        /// Encrypts the textToEncrypt and returns it as a byte array.
        /// </summary>
        /// <param name="textToEncrypt"></param>
        /// <returns></returns>
        public byte[] EncryptString(string textToEncrypt)
        {
            var encryptor = _symmetricAlgorithm.CreateEncryptor();
            byte[] encryptedBytes = null;
            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                {
                    using (var streamWriter = new StreamWriter(cryptoStream))
                    {
                        streamWriter.Write(textToEncrypt);
                    }
                    encryptedBytes = memoryStream.ToArray();
                }
            }
            return encryptedBytes;
        }

        /// <summary>
        /// Encrypts the bytesToEncrypt and returns it as a byte array.
        /// </summary>
        /// <param name="bytesToEncrypt"></param>
        /// <returns></returns>
        public byte[] EncryptBytes(byte[] bytesToEncrypt)
        {
            var encryptor = _symmetricAlgorithm.CreateEncryptor();
            byte[] encryptedBytes = null;
            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                {
                    cryptoStream.Write(bytesToEncrypt, 0, bytesToEncrypt.Length);
                }
                encryptedBytes = memoryStream.ToArray();
            }
            return encryptedBytes;
        }

        /// <summary>
        /// Encrypts the textToEncrypt and returns it as a string created
        /// from the encrypted byte array using Base64 encoding.
        /// </summary>
        /// <param name="textToEncrypt"></param>
        /// <returns></returns>
        public string EncryptStringToStringBase64(string textToEncrypt)
        {
            var encrypted = EncryptString(textToEncrypt);
            var encryptedBase64 = Convert.ToBase64String(encrypted);
            return encryptedBase64;
        }

        /// <summary>
        /// Encrypts the bytesToEncrypt and returns it as a string created
        /// from the encrypted byte array using Base64 encoding.
        /// </summary>
        /// <param name="bytesToEncrypt"></param>
        /// <returns></returns>
        public string EncryptBytesToStringBase64(byte[] bytesToEncrypt)
        {
            var encrypted = EncryptBytes(bytesToEncrypt);
            var encryptedBase64 = Convert.ToBase64String(encrypted);
            return encryptedBase64;
        }

        #endregion Encrypt

        #region Decrypt

        /// <summary>
        /// Decrypts the textBase64ToDecrypt and returns it as a byte array.
        /// </summary>
        /// <param name="textBase64ToDecrypt"></param>
        /// <returns></returns>
        public byte[] DecryptBytesFromStringBase64(string textBase64ToDecrypt)
        {
            var bytesToDecrypt = Convert.FromBase64String(textBase64ToDecrypt);
            byte[] decryptedBytes = null;
            decryptedBytes = DecryptBytes(bytesToDecrypt);
            return decryptedBytes;
        }

        /// <summary>
        /// Decrypts the bytesToDecrypt and returns it as a byte array.
        /// </summary>
        /// <param name="bytesToDecrypt"></param>
        /// <returns></returns>
        public byte[] DecryptBytes(byte[] bytesToDecrypt)
        {
            var decryptor = _symmetricAlgorithm.CreateDecryptor();
            byte[] decryptedBytes = null;
            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Write))
                {
                    cryptoStream.Write(bytesToDecrypt, 0, bytesToDecrypt.Length);
                }
                decryptedBytes = memoryStream.ToArray();
            }
            return decryptedBytes;
        }

        /// <summary>
        /// Decrypts the textBase64ToDecrypt and returns it as a string.
        /// </summary>
        /// <param name="textBase64ToDecrypt"></param>
        /// <returns></returns>
        public string DecryptStringFromStringBase64(string textBase64ToDecrypt)
        {
            var bytesToDecrypt = Convert.FromBase64String(textBase64ToDecrypt);
            var decryptedString = DecryptStringFromBytes(bytesToDecrypt);
            return decryptedString;
        }

        /// <summary>
        /// Decrypts the bytesToDecrypt and returns it as a string.
        /// </summary>
        /// <param name="bytesToDecrypt"></param>
        /// <returns></returns>
        public string DecryptStringFromBytes(byte[] bytesToDecrypt)
        {
            var decryptor = _symmetricAlgorithm.CreateDecryptor();
            string decryptedString = null;
            using (var memoryStream = new MemoryStream(bytesToDecrypt))
            {
                using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
                {
                    using (var streamReader = new StreamReader(cryptoStream))
                    {
                        decryptedString = streamReader.ReadToEnd();
                    }
                 }
            }
            return decryptedString;
        }

        #endregion Decrypt

        #region IDisposable Support
        private bool disposedValue = false; // To detect redundant calls

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    ((IDisposable)_symmetricAlgorithm).Dispose();
                }

                disposedValue = true;
            }
        }

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
        }
        #endregion

    }
}
